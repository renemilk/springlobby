#ifndef AUIUITLS_H_INCLUDED
#define AUIUITLS_H_INCLUDED

#include <wx/aui/tabmdi.h>
#include <wx/dcbuffer.h>
#include <wx/log.h>
#include <wx/image.h>

#ifdef __WXMSW__
#include <wx/msw/private.h>
#endif

#if defined(__WXMAC__) && defined(__WXOSX_CARBON__)
#include <wx/mac/carbon/private.h>
#endif

#include <wx/aui/framemanager.h>

static double wxAuiBlendColour(double fg, double bg, double alpha) {
  double result = bg + (alpha * (fg - bg));
  if (result < 0.0)
    result = 0.0;
  if (result > 255)
    result = 255;
  return result;
}

// wxAuiStepColour() it a utility function that simply darkens
// or lightens a color, based on the specified percentage
// ialpha of 0 would be completely black, 100 completely white
// an ialpha of 100 returns the same colour
static wxColor wxAuiStepColour(const wxColor& c, int ialpha) {
  if (ialpha == 100)
    return c;

  double r = c.Red(), g = c.Green(), b = c.Blue();
  double bg;

  // ialpha is 0..200 where 0 is completely black
  // and 200 is completely white and 100 is the same
  // convert that to normal alpha 0.0 - 1.0
  ialpha = wxMin(ialpha, 200);
  ialpha = wxMax(ialpha, 0);
  double alpha = ((double)(ialpha - 100.0)) / 100.0;

  if (ialpha > 100) {
    // blend with white
    bg = 255.0;
    alpha = 1.0 - alpha; // 0 = transparent fg; 1 = opaque fg
  } else {
    // blend with black
    bg = 0.0;
    alpha = 1.0 + alpha; // 0 = transparent fg; 1 = opaque fg
  }

  r = wxAuiBlendColour(r, bg, alpha);
  g = wxAuiBlendColour(g, bg, alpha);
  b = wxAuiBlendColour(b, bg, alpha);

  return wxColour((unsigned char)r, (unsigned char)g, (unsigned char)b);
}

static wxColor wxAuiLightContrastColour(const wxColour& c) {
  int amount = 120;

  // if the color is especially dark, then
  // make the contrast even lighter
  if (c.Red() < 128 && c.Green() < 128 && c.Blue() < 128)
    amount = 160;

  return wxAuiStepColour(c, amount);
}

// wxAuiBitmapFromBits() is a utility function that creates a
// masked bitmap from raw bits (XBM format)
static wxBitmap wxAuiBitmapFromBits(const unsigned char bits[], int w, int h, const wxColour& color) {
  wxImage img = wxBitmap((const char*)bits, w, h).ConvertToImage();
  img.Replace(0, 0, 0, 123, 123, 123);
  img.Replace(255, 255, 255, color.Red(), color.Green(), color.Blue());
  img.SetMaskColour(123, 123, 123);
  return wxBitmap(img);
}

// -- bitmaps --

#if defined(__WXMAC__)
static unsigned char close_bits[] = {0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFE, 0x03, 0xF8, 0x01, 0xF0, 0x19,
                                     0xF3, 0xB8, 0xE3, 0xF0, 0xE1, 0xE0, 0xE0, 0xF0, 0xE1, 0xB8, 0xE3,
                                     0x19, 0xF3, 0x01, 0xF0, 0x03, 0xF8, 0x0F, 0xFE, 0xFF, 0xFF};
#elif defined(__WXGTK__)
static unsigned char close_bits[] = {0xff, 0xff, 0xff, 0xff, 0x07, 0xf0, 0xfb, 0xef, 0xdb, 0xed, 0x8b,
                                     0xe8, 0x1b, 0xec, 0x3b, 0xee, 0x1b, 0xec, 0x8b, 0xe8, 0xdb, 0xed,
                                     0xfb, 0xef, 0x07, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
#else
static unsigned char close_bits[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xf3, 0xcf,
                                     0xf9, 0x9f, 0xfc, 0x3f, 0xfe, 0x3f, 0xfe, 0x9f, 0xfc, 0xcf, 0xf9,
                                     0xe7, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
#endif

static unsigned char left_bits[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xfe, 0x3f,
                                    0xfe, 0x1f, 0xfe, 0x0f, 0xfe, 0x1f, 0xfe, 0x3f, 0xfe, 0x7f, 0xfe,
                                    0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

static unsigned char right_bits[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0x9f, 0xff, 0x1f,
                                     0xff, 0x1f, 0xfe, 0x1f, 0xfc, 0x1f, 0xfe, 0x1f, 0xff, 0x9f, 0xff,
                                     0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

static unsigned char list_bits[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                    0xff, 0x0f, 0xf8, 0xff, 0xff, 0x0f, 0xf8, 0x1f, 0xfc, 0x3f, 0xfe,
                                    0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

static wxString wxAuiChopText(wxDC& dc, const wxString& text, int max_size) {
  wxCoord x, y;

  // first check if the text fits with no problems
  dc.GetTextExtent(text, &x, &y);
  if (x <= max_size)
    return text;

  size_t i, len = text.Length();
  size_t last_good_length = 0;
  for (i = 0; i < len; ++i) {
    wxString s = text.Left(i);
    s += wxT("...");

    dc.GetTextExtent(s, &x, &y);
    if (x > max_size)
      break;

    last_good_length = i;
  }

  wxString ret = text.Left(last_good_length);
  ret += wxT("...");
  return ret;
}

static void IndentPressedBitmap(wxRect* rect, int button_state) {
  if (button_state == wxAUI_BUTTON_STATE_PRESSED) {
    rect->x++;
    rect->y++;
  }
}

static void DrawFocusRect(wxWindow* win, wxDC& dc, const wxRect& rect, int flags) {
#if (defined(__WXMAC__))

#else
  wxUnusedVar(win);
  wxUnusedVar(flags);

  // draw the pixels manually because the "dots" in wxPen with wxDOT style
  // may be short traits and not really dots
  //
  // note that to behave in the same manner as DrawRect(), we must exclude
  // the bottom and right borders from the rectangle
  wxCoord x1 = rect.GetLeft(), y1 = rect.GetTop(), x2 = rect.GetRight(), y2 = rect.GetBottom();

  dc.SetPen(*wxBLACK_PEN);

#ifdef __WXMAC__
  dc.SetLogicalFunction(wxCOPY);
#else
  // this seems to be closer than what Windows does than wxINVERT although
  // I'm still not sure if it's correct
  dc.SetLogicalFunction(wxAND_REVERSE);
#endif

  wxCoord z;
  for (z = x1 + 1; z < x2; z += 2)
    dc.DrawPoint(z, rect.GetTop());

  wxCoord shift = z == x2 ? 0 : 1;
  for (z = y1 + shift; z < y2; z += 2)
    dc.DrawPoint(x2, z);

  shift = z == y2 ? 0 : 1;
  for (z = x2 - shift; z > x1; z -= 2)
    dc.DrawPoint(z, y2);

  shift = z == x1 ? 0 : 1;
  for (z = y2 - shift; z > y1; z -= 2)
    dc.DrawPoint(x1, z);

  dc.SetLogicalFunction(wxCOPY);
#endif
}

// -- GUI helper classes and functions --

class wxAuiCommandCapture : public wxEvtHandler {
public:
  wxAuiCommandCapture()
    : wxEvtHandler()
    , m_last_id(0) {}
  int GetCommandId() const { return m_last_id; }

  bool ProcessEvent(wxEvent& evt) {
    if (evt.GetEventType() == wxEVT_COMMAND_MENU_SELECTED) {
      m_last_id = evt.GetId();
      return true;
    }

    if (GetNextHandler())
      return GetNextHandler()->ProcessEvent(evt);

    return false;
  }

private:
  int m_last_id;
};

#endif // AUIUITLS_H_INCLUDED

/**
    This file is part of SpringLobby,
    Copyright (C) 2007-2011

    SpringLobby is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 as published by
    the Free Software Foundation.

    SpringLobby is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with SpringLobby.  If not, see <http://www.gnu.org/licenses/>.
**/
